---
title: "p8105_hw1_js5354"
author: "Jiayi Shen"
date: "9/13/2018"
output: github_document
---

```{r, include=FALSE}
library(tidyverse)
```


## Problem 1

```{r, collapse = TRUE}
problem1_df = tibble(
  random_sample = sample(0:5, 10, replace=TRUE),
  vec_logical = c(random_sample[1:10]>2),
  vec_char= c("a","b","c","d","e","f","g","h","i","end"),
  vec_factor = factor(c("Y","N", "N", "Y","N", "N", "Y","N", "N", "N"))
)

### take the mean of each variable.

mean(problem1_df$random_sample)
mean(problem1_df$vec_logical)
mean(problem1_df$vec_char)
mean(problem1_df$vec_factor)


### check the class of each variable.

class(problem1_df$random_sample)
class(problem1_df$vec_logical)
class(problem1_df$vec_char)
class(problem1_df$vec_factor)

```

Mean can be calculate for numeric and logical variables, but not for charactors and factors. 
Logical vectors are turned to integer vectors when a numerical value is required, with TRUE being mapped to 1 and FALSE to 0. However, charactor vectors and factor vectors cannot be coerced to numeric vectors in the content where a numerical value is required.


```{r, eval = FALSE}
as.numeric(problem1_df$vec_logical)
as.numeric(problem1_df$vec_char)
as.numeric(problem1_df$vec_factor)

```
Factor "Y" and "N" are converted into 1 and 2 respectively. However, characters cannot be converted to numerical values and the result displays "NA". 

We are getting this result because the as.numeric function turns factor vectors into underlying numeric representation, though meaningless. However, as.numeric function is not capable of turning letter(s) into numbers so we get "NA" when we apply this function to character vectors.



```{r}
as.numeric(as.factor(problem1_df$vec_char))
as.numeric(as.character(problem1_df$vec_factor))
```

When character varialbes are first converted to factor and then numeric variables, they are assigned positive intergers starting from 1, in an alphebetic order. On the other hand, when factor varialbes are converted to character and then to numeric, "NA"s were introduced. 


## Problem 2

```{r}
problem2_df = tibble(
  x = rnorm (1000, mean = 0, sd = 1),
  y = rnorm (1000, mean = 0, sd = 1),
  vec2_logical = c( x + y > 0 ), 
  vec2_numeric = as.numeric(vec2_logical),
  vec2_factor = as.factor(vec2_logical)
)

true_proportion = sum(problem2_df$vec2_logical, na.rm=TRUE) / length(problem2_df$vec2_logical)


```

The size of the dataset is `r dim(problem2_df)` (rows, columns).\
The mean of x is `r mean(problem2_df$x)` ; the median of x is `r median(problem2_df$x)`.\
There are `r true_proportion * 100` % of cases for which the logical vector is TRUE.


```{r}
ggplot(problem2_df, aes(x = x, y = y, color = vec2_logical)) + geom_point()
ggsave("hw1_first_plot.pdf")
ggplot(problem2_df, aes(x = x, y = y, color = vec2_numeric)) + geom_point()
ggplot(problem2_df, aes(x = x, y = y, color = vec2_factor)) + geom_point()

```

All three plots produce scatter plots in which two discrete colors are seperated by a straight line y = -x. Coloring by numeric vector generates four discrete color scales evenly spaced between 0 and 1. Because the numeric vector is previously coerced from the logical vector so it only takes values of 0 and 1, the plot that is colored according to numeric vector displays dots of only two colors.
